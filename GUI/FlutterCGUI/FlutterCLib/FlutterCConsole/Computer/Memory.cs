//------------------------------------------------------------------------------
// <auto-generated>
//     Этот код создан инструментальным средством
//     В случае повторного создания кода изменения, внесенные в этот файл, будут потеряны.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;

using FlutterCConsole;
using System.IO;

using FlutterCConsole.Exceptions;

public class Memory
{
    public static Memory instance = null;
    private Dictionary<String, Variable> variables;
    public CellMemory cellMemory;

    public static int stackSize = 30000000;

    public Value[] stack = new Value[stackSize];
    public int stackPointer = 0;
    public Stack<FunctionBody> callStack;

    public Dictionary<string, FunctionBody> availableFunctions;
    public Dictionary<string, StructureDeclaration> availableStructs;

    public bool functionReturnFlag = false;
    public bool breakFlag = false;
    public bool continueFlag = false;

    public int breakIndex = -1;
    public int continueIndex = -1;

    public string inFile;

    public LinearNode globalNode;

    public PerfomanceReport report;

    public string output;

    private List<string> inputTokens;
    private int tokensPointer = 0;

    public bool isAlgoRegime = false;

    public Dictionary<FunctionBody, Dictionary<string, Variable>> precalcBelongness;

    public static void reinit(){
        instance = new Memory();
    }

    public void precalc()
    {
        precalcBelongness = new Dictionary<FunctionBody, Dictionary<string, Variable>>();
        foreach(var i in availableFunctions){
            Dictionary<string, Variable> que = i.Value.getNonGlobalVariables();
            precalcBelongness.Add(i.Value, que);
        }
    }

    private Memory()
    {
        this.variables = new Dictionary<string, Variable>();
        stackPointer = 0;
        callStack = new Stack<FunctionBody>();
        availableFunctions = new Dictionary<string, FunctionBody>();
        availableStructs = new Dictionary<string, StructureDeclaration>();
        cellMemory = new CellMemory();
        report = new PerfomanceReport();
        globalNode = new LinearNode();
        NameInventor.reset();
    }

    public string nextToken()
    {
        if (tokensPointer < inputTokens.Count)
        {
            tokensPointer++;
            return inputTokens[tokensPointer - 1];
        }
        else
        {
            throw new InputHasGone();
        }
    }

    public void setGlobal(LinearNode global)
    {
        List<Node> l = global.getNodes();
        for (int i = 0; i < l.Count; i++)
        {
            globalNode.addNode(l[i]);
        }
    }

    public static List<string> getContents(List<string> files)
    {
        List<string> res = new List<string>();
        for (int i = 0; i < files.Count; i++ )
        {
            res.Add(File.ReadAllText(files[i]));
        }
        return res;
    }

    public static void setUp(List<string> contents)
    {
        instance = new Memory();
        Thread.CurrentThread.CurrentCulture = System.Globalization.CultureInfo.InvariantCulture;
        List<string> tokensForParsing = TokensCollector.collectTokens(contents);
        SyntaxParser.parseTokens(tokensForParsing);
    }

    public bool canLaunch()
    {
        return availableFunctions.ContainsKey("main$0");
    }

    public bool canAlgoLaunch()
    {
        return availableFunctions.ContainsKey("main$1");
    }

    public void loadTokens(string input)
    {
        inputTokens = input.Split(' ').ToList<string>();
        tokensPointer = 0;
    }

    public string launch(string input, bool pr)
    {
        precalc();
        output = "";
        inputTokens = input.Split(' ').ToList<string>();
        tokensPointer = 0;
        NameInventor.reset();
        globalNode.execute();

        callStack.Push(availableFunctions["main$0"]);
        availableFunctions["main$0"].execute();

        if (pr)
        {
            output += "Perfomance report:\n";
            output += getPerfomanceDump();
        }
        return output;
    }

    public Node getLastNode()
    {
        return report.commands.Peek();
    }

    public string currentInstruction()
    {
        List<string> l =  getLastNode().instruction;
        string res = getLastNode().type()+"\nin "+"<";
        if(l!=null){
            res += Utils.merge(l, " ")+">";
        }
        else
        {
            res += ">";
        }
        res += "\nin function " + getLastNode().functionName;
        return res;
    }

    public string memoryDump(bool isStack, FunctionBody que)
    {
        string res = "";

        if (isStack)
        {
            res += "Variables:\n";
        }

        var vars = que.getFunctionVariables();

        foreach (var i in vars)
        {
            if(i.Key!=FunctionBody.RETURN_VAR){
                res += i.Key + "=" + i.Value.get().ToString() + "\n";
            }
        }

        if (isStack)
        {
            res += "Call stack:\n";
            Stack<FunctionBody> cs = new Stack<FunctionBody>();

            int counter = 0;
            while (this.callStack.Count > 0)
            {
                FunctionBody item = callStack.Peek();
                res += new string('\t', counter) + item.name + "\n";
                cs.Push(item);
                callStack.Pop();
                counter++;
            }


            while (cs.Count > 0)
            {
                FunctionBody item = cs.Peek();
                callStack.Push(item);
                cs.Pop();
            }
        }

        res += "\n\n";
        return res;
    }

    public string memoryDumpException(bool isStack)
    {
        FunctionBody th = callStack.Peek();
        string res = memoryDump(isStack, th);
        return res;
    }

    public string memoryDumpFun(bool isStack)
    {
        FunctionBody th = callStack.Peek();
        callStack.Pop();
        FunctionBody last = callStack.Peek();
        callStack.Push(th);
        string res = memoryDump(isStack, last);
        return res;
    }

    public AlgoAnalysisReport algoLaunch(double beginN, double endN, double h)
    {
        precalc();
        isAlgoRegime = true;
        AlgoAnalysisReport report = new AlgoAnalysisReport(beginN, endN, h);
        inputTokens = new List<string>();
        tokensPointer = 0;

        for (double x = beginN; x <= endN+0.00000001; x += h)
        {
            this.report = new PerfomanceReport();

            stackPointer = 0;
            callStack = new Stack<FunctionBody>();
            Value v = new Value("double", false);
            v.value = (decimal)x;
            globalNode.execute();
            push(v);
            availableFunctions["main$1"].execute();
            report.done(this.report);
        }
        isAlgoRegime = false;
        return report;
    }

    public string getVarDump()
    {
        string res = "";
        var vars = Memory.getInstance().getVariablesMap();
        foreach (var i in vars)
        {
            res += i.Key + "=" + i.Value + "\n";
        }
        return res;
    }

    public void nodeExecuted(Node node)
    {
        report.nodeExecuted(node);
    }

    public string getPerfomanceDump()
    {
        return report.ToString();
    }

    public void reset()
    {
        this.variables = new Dictionary<string, Variable>();
        stackPointer = 0;
        callStack = new Stack<FunctionBody>();
        availableFunctions = new Dictionary<string, FunctionBody>();
        availableStructs = new Dictionary<string, StructureDeclaration>();
        cellMemory = new CellMemory();
        report = new PerfomanceReport();
    }

    public void allocateVariable(Value val)
    {
        cellMemory.allocateVariable(val);
    }

    public Dictionary<string, FunctionBody> getFunctionsMap()
    {
        return availableFunctions;
    }


    public List<KeyValuePair<string, int>> getFunctionsRawNames()
    {
        List<KeyValuePair<string, int>> res = new List<KeyValuePair<string, int>>();

        foreach (var i in availableFunctions)
        {
            string name = "";
            if (i.Key.IndexOf("$") != -1)
            {
                name = i.Key.Substring(0, i.Key.IndexOf("$"));
            }
            else
            {
                name = i.Key;
            }
            res.Add(new KeyValuePair<string, int>(name, i.Value.argNumber));
        }

        return res;
    }


    public Dictionary<string, Value> getVariablesMap()
    {
        Dictionary<string, Value> res = new Dictionary<string, Value>();
        foreach (var i in variables)
        {
            res.Add(i.Key, i.Value.values.Peek());
        }
        return res;
    }


    public void showFunction()
    {
        Console.WriteLine("There are " + availableFunctions.Count + " functions");
        foreach (var i in availableFunctions)
        {
            Console.WriteLine(i.Value);
            Console.WriteLine();
            Console.WriteLine();
        }
    }


    public void showStructs()
    {
        Console.WriteLine("There are " + availableStructs.Count + " structs");
        foreach (var i in availableStructs)
        {
            Console.WriteLine(i.Value);
            Console.WriteLine();
            Console.WriteLine();
        }
    }

    
    public List<Variable> getAllVariables()
    {
        //return this.valiableList;
        List<Variable> res = new List<Variable>();
        foreach(var i in variables){
            res.Add(i.Value);
        }
        return res;
    }
    
    public void addAvailableFunction(FunctionBody body)
    {
        this.availableFunctions.Add(body.name, body);
    }

    public void addAvailableStruct(StructureDeclaration decl)
    {
        this.availableStructs.Add(decl.name, decl);
    }

    public void push(Value value)
    {
        stack[stackPointer] = value;
        stackPointer++;
    }

    public void pop()
    {
        stackPointer--;
    }

    public Value peek()
    {
        return stack[stackPointer - 1];
    }

    public static Memory getInstance()
    {
        if (instance == null)
        {
            instance = new Memory();
        }
        return instance;
    }

    public void addVariable(string name, Variable a)
    {
        if (!this.variables.ContainsKey(a.longname))
        {
            variables.Add(a.longname, a);
        }
        else
        {
            throw new FlutterCConsole.Exceptions.NameConflictException(a.longname, "");
        }
    }

    public Value getValueByName(string name)
    {
        return variables[name].values.Peek();
    }

    public void pushCall(FunctionBody f)
    {
        Dictionary<String, Variable> map = precalcBelongness[f];
        foreach (var i in map)
        {
            i.Value.Push();
        }
        callStack.Push(f);
    }

    public FunctionBody peekCall()
    {
        return callStack.Peek();
    }

    public void popCall()
    {
        FunctionBody fb = callStack.Peek();
        Dictionary<String, Variable> map = precalcBelongness[fb];
        foreach (var i in map)
        {
            i.Value.free();
            i.Value.Pop();
        }
        callStack.Pop();
    }

    public void returnToCall()
    {
        while (stackPointer >= 0)
        {
            if (peek() is CallMarker)
            {
                pop();
                break;
            }
            else
            {
                pop();
            }
        }
    }
}

